"""
GitHub Action entrypoint:  changed *.ipynb → *.py (nbconvert) → commit back.
"""

from __future__ import annotations
    
import json
import os
import subprocess
import sys
import tempfile
from pathlib import Path
from typing import Final, Sequence

import nbformat  # type: ignore
from nbconvert import PythonExporter  # type: ignore

ZERO_SHA: Final[str] = "0" * 40
# Header inserted at the top of generated python files
GEN_HEADER: Final[str] = "# Generated by gha-nbconvert action. Do not edit manually.\n"


class PathTraversalError(ValueError):
    """Raised when a path would leave the repository root."""


def _ensure_writable_home() -> None:
    """Set $HOME to a writable directory for git global config."""
    candidates = [Path("/home/nbconvert"), Path(os.environ.get("HOME", ""))]
    for cand in candidates:
        if cand and cand.exists():
            try:
                cand.mkdir(parents=True, exist_ok=True)
            except PermissionError:
                continue
            if os.access(cand, os.W_OK):
                os.environ["HOME"] = str(cand)
                return

    # Fallback: create a temporary writable home
    tmp_home = Path(tempfile.mkdtemp(prefix="nbconvert_home_"))
    os.environ["HOME"] = str(tmp_home)


def _validate_path_inside_repo(*, path: Path, repo_root: Path) -> None:
    """Ensure *path* is inside *repo_root*; raise if not."""
    if not isinstance(path, Path) or not isinstance(repo_root, Path):
        raise ValueError("path and repo_root must be pathlib.Path instances")
    try:
        path.resolve().relative_to(repo_root.resolve())
    except ValueError as exc:  # path is outside repo_root
        raise PathTraversalError(f"Disallowed path outside repository: {path}") from exc


def _run_git(*, args: Sequence[str], cwd: Path) -> str:
    """Run git and return stdout."""
    if not isinstance(args, Sequence) or not all(isinstance(a, str) for a in args):
        raise ValueError("args must be sequence[str]")
    try:
        result = subprocess.run(
            ["git", *args],
            cwd=cwd,
            text=True,
            capture_output=True,
            check=True,
        )
    except subprocess.CalledProcessError as exc:
        # propagate with captured stdout/stderr for better diagnostics
        err_msg = f"git {' '.join(args)} failed. stdout:\n{exc.stdout}\nstderr:\n{exc.stderr}"
        raise subprocess.CalledProcessError(exc.returncode, exc.cmd, output=exc.stdout, stderr=err_msg) from exc
    return result.stdout.strip()


def _mark_repo_safe(*, repo_root: Path) -> None:
    """
    Add *repo_root* to git's global safe.directory list
    to avoid 'dubious ownership' errors inside the container.
    """
    _run_git(
        args=["config", "--global", "--add", "safe.directory", str(repo_root)],
        cwd=repo_root,
    )


def _shas_from_event(event: dict, *, event_name: str) -> tuple[str, str]:
    """Return (before_sha, after_sha) for push or pull_request."""
    if event_name == "pull_request":
        pr = event.get("pull_request", {})
        return (
            pr.get("base", {}).get("sha", ZERO_SHA),
            pr.get("head", {}).get("sha", ZERO_SHA),
        )
    # fall-back: push / workflow_dispatch
    return (
        event.get("before", ZERO_SHA),
        event.get("after", ZERO_SHA),
    )


def _git_object_exists(*, sha: str, repo_root: Path) -> bool:
    """Return True iff *sha* exists in the repository object database."""
    if not isinstance(sha, str) or not isinstance(repo_root, Path):
        raise ValueError("sha must be str and repo_root must be pathlib.Path")
    try:
        _run_git(args=["cat-file", "-e", f"{sha}^{{commit}}"], cwd=repo_root)
        return True
    except subprocess.CalledProcessError:
        return False


def _diff_changed_notebooks(
    *, repo_root: Path, before: str, after: str
) -> list[Path]:
    """
    Return a list of *.ipynb files modified between *before* and *after*.
    """
    if not all(isinstance(s, str) for s in (before, after)):
        raise ValueError("before and after must be str")

    if before == ZERO_SHA or not _git_object_exists(sha=before, repo_root=repo_root):
        diff_args = ["diff-tree", "--no-commit-id", "--name-only", "-r", after]
    else:
        diff_args = ["diff", "--name-only", before, after]

    diff_output: str = _run_git(args=diff_args, cwd=repo_root)
    paths = [
        repo_root / p
        for p in diff_output.splitlines()
        if p.endswith(".ipynb") and p  # notebook file name 
        and (repo_root / p).is_file()  # keep only files that exist in the after state
    ]
    return paths


def _get_branch_from_ref(ref: str) -> Optional[str]:
    """Extract the branch name from a Git ref. Return None for non-head refs."""
    if ref.startswith("refs/heads/"):
        return ref.split("/", maxsplit=2)[-1]
    return None


def _notebook_to_py_path(
    *, notebook_path: Path, repo_root: Path, output_dir: Path
) -> Path:
    """Return destination *.py path under output_dir mirroring original layout."""
    _validate_path_inside_repo(path=notebook_path, repo_root=repo_root)
    relative_path: Path = notebook_path.relative_to(repo_root)
    destination_path: Path = repo_root / output_dir / relative_path.with_suffix(".py")
    _validate_path_inside_repo(path=destination_path, repo_root=repo_root)
    return destination_path


def _convert_notebook(*, notebook_path: Path, destination_path: Path) -> None:
    """Convert notebook to Python script using nbconvert PythonExporter."""
    if not notebook_path.is_file():
        raise FileNotFoundError(f"Notebook not found: {notebook_path}")
    destination_path.parent.mkdir(parents=True, exist_ok=True)

    exporter = PythonExporter()
    script, _ = exporter.from_file(notebook_path)
    destination_path.write_text(GEN_HEADER + script, encoding="utf-8")


def _commit_and_push(*, repo_root: Path, files: Sequence[Path], branch: str) -> None:
    """Commit and push generated files."""
    if not files:
        return
    _run_git(args=["config", "user.name", "github-actions[bot]"], cwd=repo_root)
    _run_git(
        args=["config", "user.email", "github-actions[bot]@users.noreply.github.com"],
        cwd=repo_root,
    )
    _run_git(args=["add", *map(str, files)], cwd=repo_root)
    _run_git(
        args=["commit", "-m", "chore(nbconvert): auto-generate *.py from *.ipynb"],
        cwd=repo_root,
    )
    _run_git(args=["push", "origin", branch], cwd=repo_root)


def main() -> None:  # noqa: C901 – main entrypoint
    _ensure_writable_home()

    workspace = os.environ.get("GITHUB_WORKSPACE")
    if not workspace or not Path(workspace).exists():
        print("::error::GITHUB_WORKSPACE is not set or does not exist", file=sys.stderr)
        sys.exit(1)
    repo_root: Final[Path] = Path(workspace).resolve()

    _mark_repo_safe(repo_root=repo_root)
    event_path = os.environ.get("GITHUB_EVENT_PATH")
    if not event_path:
        print("GITHUB_EVENT_PATH not set; exiting", file=sys.stderr)
        sys.exit(78)  # neutral
    with Path(event_path).open(encoding="utf-8") as filepath:
        event = json.load(filepath)

    event_name = os.environ.get("GITHUB_EVENT_NAME", "")
    before_sha, after_sha = _shas_from_event(event, event_name=event_name)

    if event_name != "pull_request":
        print(f"Event '{event_name}' not supported; skipping.")
        return

    # Skip because write permission is not available in fork PR
    pr_repo = event["pull_request"]["head"]["repo"]["full_name"]
    base_repo = event["repository"]["full_name"]
    if pr_repo != base_repo:
        print("Pull request originates from a fork; skipping conversion.")
        return
    branch = os.environ.get("GITHUB_HEAD_REF") or event["pull_request"]["head"]["ref"]
    if not branch:
        print(f"Ref {ref} is not a branch ref; skipping conversion.")
        return

    # Determine output directory; default to artifacts/gha-nbconvert or use INPUT_OUTPUT_DIR
    output_dir_env = os.environ.get("INPUT_OUTPUT_DIR", "artifacts/gha-nbconvert")
    output_dir: Path = repo_root / output_dir_env

    changed_notebooks: list[Path] = _diff_changed_notebooks(repo_root=repo_root, before=before_sha, after=after_sha)
    if not changed_notebooks:
        print("No notebook changes detected – skipping conversion.")
        return

    generated_files: list[Path] = []
    for nb in changed_notebooks:
        destination_path: Path = _notebook_to_py_path(
            notebook_path=nb, repo_root=repo_root, output_dir=output_dir
        )
        print(f"Converting {nb} → {destination_path}")
        _convert_notebook(notebook_path=nb, destination_path=destination_path)
        if destination_path.exists():
            generated_files.append(destination_path)

    if generated_files:
        _commit_and_push(repo_root=repo_root, files=generated_files, branch=branch)
        print("nbconvert finished.")
    else:
        print("No files were generated to commit.")


if __name__ == "__main__":
    try:
        main()
    except PathTraversalError as exc:
        print(f"::error::{exc}", file=sys.stderr)
        sys.exit(1)
    except subprocess.CalledProcessError as exc:
        # exc.stderr may already include both stdout and stderr
        print(f"::error::git command failed: {exc.stderr}", file=sys.stderr)
        sys.exit(exc.returncode)
    except Exception as exc:
        print(f"::error::Unexpected error: {exc}", file=sys.stderr)
        sys.exit(1)
